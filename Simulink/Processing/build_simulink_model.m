function build_simulink_model()
%BUILD_SIMULINK_MODEL Builds a Simulink model for momentum-only plant:
% xdot = tau_ext - [B]_x*m

model = "mtq_desat_mpc_model";
if bdIsLoaded(model); close_system(model,0); end
new_system(model); open_system(model);

% Basic layout positions
x0 = 40; y0 = 40; dx = 180; dy = 80;
nl = newline;

% Pull parameters from base workspace for script embedding
if evalin("base","exist('P','var') ~= 1")
    error("Parameter struct 'P' not found in base workspace. Run: P = params_default(); assignin('base','P',P);");
end
P = evalin("base","P");
Ts_str = num2str(P.Ts, 16);
B0_str = num2str(P.B0_T, 16);
tau_ext_str = mat2str(P.tau_ext_const(:), 16);
KH_str = mat2str(P.KH, 16);
m_max_str = mat2str(P.m_max(:), 16);
x0_str = mat2str(P.x0(:), 16);
Tend_str = num2str(P.Tend, 16);
Re_str = num2str(P.earth.Re_m, 16);
mu_str = num2str(P.earth.mu_m3s2, 16);
omega_str = num2str(P.earth.omega_radps, 16);
tilt_str = num2str(deg2rad(P.earth.dipole_tilt_deg), 16);
alt_str = num2str(P.orbit.alt_m, 16);
inc_str = num2str(deg2rad(P.orbit.inc_deg), 16);
theta0_str = num2str(deg2rad(P.orbit.theta0_deg), 16);

% Environment flags/params (embedded as constants for Simulink MATLAB Function blocks)
en_bias_str = bool2str(~isfield(P,'env') || ~isfield(P.env,'enable_bias') || P.env.enable_bias);
en_per_str = bool2str(isfield(P,'env') && isfield(P.env,'enable_periodic') && P.env.enable_periodic);
en_gg_str = bool2str(isfield(P,'env') && isfield(P.env,'enable_gravity_gradient') && P.env.enable_gravity_gradient);
en_drag_str = bool2str(isfield(P,'env') && isfield(P.env,'enable_drag') && P.env.enable_drag);

I_str = mat2str(P.sc.I_kgm2, 16);
Cd_str = num2str(P.sc.Cd, 16);
Area_str = num2str(P.sc.area_m2, 16);
cp_str = mat2str(P.sc.cp_offset_m(:), 16);

rho_ref_str = num2str(P.env.drag_rho_ref_kgm3, 16);
alt_ref_str = num2str(P.env.drag_alt_ref_m, 16);
H_str = num2str(P.env.drag_scale_height_m, 16);
drag_scale_str = num2str(P.env.drag_scale, 16);
gg_scale_str = num2str(P.env.gg_scale, 16);

% Blocks
add_block("simulink/Sources/Clock", model+"/Clock", "Position",[x0 y0 x0+60 y0+30]);
add_block("simulink/User-Defined Functions/MATLAB Function", model+"/B_field", ...
    "Position",[x0+dx y0 x0+dx+120 y0+60]);
add_block("simulink/User-Defined Functions/MATLAB Function", model+"/Tau_ext", ...
    "Position",[x0+dx y0+dy x0+dx+120 y0+dy+60]);

add_block("simulink/User-Defined Functions/MATLAB Function", model+"/Controller", ...
    "Position",[x0+2*dx y0+0.5*dy x0+2*dx+140 y0+0.5*dy+90]);

add_block("simulink/Math Operations/Gain", model+"/TsGain", ...
    "Gain",Ts_str, "Position",[x0+3*dx y0+0.5*dy x0+3*dx+60 y0+0.5*dy+50]);

add_block("simulink/Continuous/Integrator", model+"/Int_x", ...
    "Position",[x0+4*dx y0+0.5*dy x0+4*dx+60 y0+0.5*dy+60]);
set_param(model+"/Int_x","InitialCondition",x0_str);

add_block("simulink/Sinks/To Workspace", model+"/x_log", ...
    "VariableName","x_log", "SaveFormat","StructureWithTime", ...
    "Position",[x0+5*dx y0+0.5*dy x0+5*dx+100 y0+0.5*dy+60]);

add_block("simulink/Sinks/To Workspace", model+"/m_log", ...
    "VariableName","m_log", "SaveFormat","StructureWithTime", ...
    "Position",[x0+3*dx y0+1.4*dy x0+3*dx+100 y0+1.4*dy+60]);

add_block("simulink/Sinks/To Workspace", model+"/B_log", ...
    "VariableName","B_log", "SaveFormat","StructureWithTime", ...
    "Position",[x0+2*dx y0 x0+2*dx+100 y0+60]);

add_block("simulink/Sinks/To Workspace", model+"/tau_ext_log", ...
    "VariableName","tau_ext_log", "SaveFormat","StructureWithTime", ...
    "Position",[x0+2*dx y0+dy x0+2*dx+100 y0+dy+60]);

add_block("simulink/Sinks/To Workspace", model+"/tau_mtq_log", ...
    "VariableName","tau_mtq_log", "SaveFormat","StructureWithTime", ...
    "Position",[x0+3.7*dx y0+1.4*dy x0+3.7*dx+110 y0+1.4*dy+60]);

add_block("simulink/Sinks/To Workspace", model+"/tau_total_log", ...
    "VariableName","tau_total_log", "SaveFormat","StructureWithTime", ...
    "Position",[x0+4.6*dx y0+1.4*dy x0+4.6*dx+110 y0+1.4*dy+60]);

% Sum: tau_ext + tau_mtq
add_block("simulink/Math Operations/Sum", model+"/SumTau", ...
    "Inputs","++", "Position",[x0+3*dx y0+0.5*dy-40 x0+3*dx+40 y0+0.5*dy]);

% tau_mtq = -[B]_x*m implemented in MATLAB Function "MTQ_Torque"
add_block("simulink/User-Defined Functions/MATLAB Function", model+"/MTQ_Torque", ...
    "Position",[x0+2.5*dx y0+1.4*dy x0+2.5*dx+140 y0+1.4*dy+90]);

% Fill MATLAB Function blocks (defines ports before wiring)
set_mfcn_script(model+"/B_field", ...
"function B = fcn(t)" + nl + ...
"%#codegen" + nl + ...
"Ts = " + Ts_str + ";" + nl + ...
"Re = " + Re_str + ";" + nl + ...
"mu = " + mu_str + ";" + nl + ...
"omega = " + omega_str + ";" + nl + ...
"tilt = " + tilt_str + ";" + nl + ...
"alt = " + alt_str + ";" + nl + ...
"inc = " + inc_str + ";" + nl + ...
"theta0 = " + theta0_str + ";" + nl + ...
"B0_T = " + B0_str + ";" + nl + ...
"k = floor(t/Ts)+1;" + nl + ...
"tsec = (k-1)*Ts;" + nl + ...
"r_orb = Re + alt;" + nl + ...
"w = sqrt(mu / (r_orb^3));" + nl + ...
"theta = theta0 + w * tsec;" + nl + ...
"r_orb_plane = r_orb * [cos(theta); sin(theta); 0];" + nl + ...
"R1 = [1 0 0; 0 cos(inc) -sin(inc); 0 sin(inc) cos(inc)];" + nl + ...
"r_eci = R1 * r_orb_plane;" + nl + ...
"ct = cos(omega*tsec);" + nl + ...
"st = sin(omega*tsec);" + nl + ...
"R3 = [ct st 0; -st ct 0; 0 0 1];" + nl + ...
"r_ecef = R3 * r_eci;" + nl + ...
"rn = norm(r_ecef);" + nl + ...
"r_hat = r_ecef / rn;" + nl + ...
"m_hat = [sin(tilt); 0; cos(tilt)];" + nl + ...
"mr = m_hat' * r_hat;" + nl + ...
"B_ecef = B0_T * (Re/rn)^3 * (3*r_hat*mr - m_hat);" + nl + ...
"B = R3' * B_ecef;" + nl + ...
"end" + nl);
set_mfcn_output_size(model+"/B_field", "B", "3");
set_mfcn_input_size(model+"/B_field", "t", "1");

set_mfcn_script(model+"/Tau_ext", ...
"function tau = fcn(t)" + nl + ...
"%#codegen" + nl + ...
"Ts = " + Ts_str + ";" + nl + ...
"Re = " + Re_str + ";" + nl + ...
"mu = " + mu_str + ";" + nl + ...
"alt = " + alt_str + ";" + nl + ...
"inc = " + inc_str + ";" + nl + ...
"theta0 = " + theta0_str + ";" + nl + ...
"tau_ext_const = " + tau_ext_str + ";" + nl + ...
"enable_bias = " + en_bias_str + ";" + nl + ...
"enable_periodic = " + en_per_str + ";" + nl + ...
"enable_gg = " + en_gg_str + ";" + nl + ...
"enable_drag = " + en_drag_str + ";" + nl + ...
"I = " + I_str + ";" + nl + ...
"gg_scale = " + gg_scale_str + ";" + nl + ...
"Cd = " + Cd_str + ";" + nl + ...
"Area = " + Area_str + ";" + nl + ...
"cp = " + cp_str + ";" + nl + ...
"rho_ref = " + rho_ref_str + ";" + nl + ...
"alt_ref = " + alt_ref_str + ";" + nl + ...
"H = " + H_str + ";" + nl + ...
"drag_scale = " + drag_scale_str + ";" + nl + ...
"k = floor(t/Ts)+1;" + nl + ...
"tsec = (k-1)*Ts;" + nl + ...
"tau = [0;0;0];" + nl + ...
"if enable_bias" + nl + ...
"  tau = tau + tau_ext_const;" + nl + ...
"end" + nl + ...
"if enable_periodic" + nl + ...
"  tau = tau + 1e-6*[sin(2*pi*tsec/600); cos(2*pi*tsec/800); sin(2*pi*tsec/1000)];" + nl + ...
"end" + nl + ...
"% Orbit state (ECI) for GG + drag" + nl + ...
"r_orb = Re + alt;" + nl + ...
"w = sqrt(mu / (r_orb^3));" + nl + ...
"theta = theta0 + w * tsec;" + nl + ...
"r_orb_plane = r_orb * [cos(theta); sin(theta); 0];" + nl + ...
"v_orb_plane = r_orb * w * [-sin(theta); cos(theta); 0];" + nl + ...
"R1 = [1 0 0; 0 cos(inc) -sin(inc); 0 sin(inc) cos(inc)];" + nl + ...
"r_eci = R1 * r_orb_plane;" + nl + ...
"v_eci = R1 * v_orb_plane;" + nl + ...
"rn = norm(r_eci);" + nl + ...
"alt_m = max(0, rn - Re);" + nl + ...
"if enable_gg" + nl + ...
"  rhat = r_eci / max(rn, 1.0);" + nl + ...
"  tau_gg = gg_scale * (3*mu/max(rn^3, 1.0)) * cross(rhat, I*rhat);" + nl + ...
"  tau = tau + tau_gg;" + nl + ...
"end" + nl + ...
"if enable_drag" + nl + ...
"  rho = rho_ref * exp(-(alt_m - alt_ref)/max(H, 1.0));" + nl + ...
"  rho = max(rho, 0);" + nl + ...
"  vmag = norm(v_eci);" + nl + ...
"  if vmag > 1e-9" + nl + ...
"    vhat = v_eci / vmag;" + nl + ...
"    Fdrag = -0.5 * rho * Cd * Area * vmag^2 * vhat;" + nl + ...
"    tau_drag = drag_scale * cross(cp, Fdrag);" + nl + ...
"    tau = tau + tau_drag;" + nl + ...
"  end" + nl + ...
"end" + nl + ...
"end" + nl);
set_mfcn_output_size(model+"/Tau_ext", "tau", "3");
set_mfcn_input_size(model+"/Tau_ext", "t", "1");

set_mfcn_script(model+"/MTQ_Torque", ...
"function tau_mtq = fcn(m, B)" + nl + ...
"%#codegen" + nl + ...
"tau_mtq = cross(m, B);" + nl + ...
"end" + nl);
set_mfcn_output_size(model+"/MTQ_Torque", "tau_mtq", "3");
set_mfcn_input_size(model+"/MTQ_Torque", "m", "3");
set_mfcn_input_size(model+"/MTQ_Torque", "B", "3");

set_mfcn_script(model+"/Controller", ...
"function m = fcn(x, B)" + nl + ...
"%#codegen" + nl + ...
"KH = " + KH_str + ";" + nl + ...
"m_max = " + m_max_str + ";" + nl + ...
"tau_des = -KH * x(:);" + nl + ...
"Bn2 = max(dot(B,B), 1e-12);" + nl + ...
"m = cross(B, tau_des) / Bn2;" + nl + ...
"m = min(max(m, -m_max), m_max);" + nl + ...
"end" + nl);
set_mfcn_output_size(model+"/Controller", "m", "3");
set_mfcn_input_size(model+"/Controller", "x", "3");
set_mfcn_input_size(model+"/Controller", "B", "3");

set_param(model, "SimulationCommand", "update");

% Wire connections
add_line(model,"Clock/1","B_field/1");
add_line(model,"Clock/1","Tau_ext/1");

add_line(model,"Int_x/1","Controller/1");     % x -> controller
add_line(model,"B_field/1","Controller/2");   % B -> controller
add_line(model,"B_field/1","B_log/1");        % log B

add_line(model,"Controller/1","m_log/1");     % log m
add_line(model,"Controller/1","MTQ_Torque/1");% m -> mtq torque
add_line(model,"B_field/1","MTQ_Torque/2");   % B -> mtq torque

add_line(model,"Tau_ext/1","SumTau/1");       % tau_ext
add_line(model,"Tau_ext/1","tau_ext_log/1");  % log tau_ext
add_line(model,"MTQ_Torque/1","SumTau/2");    % tau_mtq
add_line(model,"MTQ_Torque/1","tau_mtq_log/1"); % log tau_mtq

add_line(model,"SumTau/1","TsGain/1");
add_line(model,"SumTau/1","tau_total_log/1"); % log total torque
add_line(model,"TsGain/1","Int_x/1");
add_line(model,"Int_x/1","x_log/1");

% Set model variables
set_param(model,"Solver","ode4","FixedStep",Ts_str);
set_param(model,"StopTime",Tend_str);

save_system(model);
disp("Built Simulink model: " + model + ".slx");
end

function set_mfcn_script(blockPath, scriptText)
%SET_MFCN_SCRIPT Assign script to MATLAB Function block via Stateflow API.
rt = sfroot;
ch = rt.find('-isa','Stateflow.EMChart','Path', blockPath);
if isempty(ch)
    error("Could not find Stateflow chart for block: %s", blockPath);
end
ch.Script = char(scriptText);
end

function set_mfcn_output_size(blockPath, outputName, sizeSpec)
%SET_MFCN_OUTPUT_SIZE Force output size for MATLAB Function block.
rt = sfroot;
ch = rt.find('-isa','Stateflow.EMChart','Path', blockPath);
if isempty(ch)
    error("Could not find Stateflow chart for block: %s", blockPath);
end
outData = ch.find('-isa','Stateflow.Data','Scope','Output');
for i = 1:numel(outData)
    if strcmp(outData(i).Name, outputName)
        outData(i).Props.Array.Size = sizeSpec;
    end
end
end

function set_mfcn_input_size(blockPath, inputName, sizeSpec)
%SET_MFCN_INPUT_SIZE Force input size for MATLAB Function block.
rt = sfroot;
ch = rt.find('-isa','Stateflow.EMChart','Path', blockPath);
if isempty(ch)
    error("Could not find Stateflow chart for block: %s", blockPath);
end
inData = ch.find('-isa','Stateflow.Data','Scope','Input');
for i = 1:numel(inData)
    if strcmp(inData(i).Name, inputName)
        inData(i).Props.Array.Size = sizeSpec;
    end
end
end

function s = bool2str(tf)
%BOOL2STR Convert logical to Simulink-compatible literal.
if tf
    s = "true";
else
    s = "false";
end
end
